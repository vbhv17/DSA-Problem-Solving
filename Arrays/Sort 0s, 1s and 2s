=> Sort an array of 0s, 1s and 2s/ Sort Colors

//Bruteforce Solution 
Approach : Since we just have to sort the array, we use the inbuilt sort function of JAVA 


Explanation : NA


CODE :
class Solution {
    public void sortColors(int[] nums) {
      Arrays.sort(nums);

    }
}

TC : O(NLogN)
SC : O(1)

********************************************************************

//Better Solution 
Approach : We know that we have only 0s, 1s and 2s in the array. And hence what we can do is, 
           We can iterate over the entire array once and count the total number of 0s, 1s and 2s we have in the array.
           Once we have this information with us, we can start by adding that many number of 0s in the array followed by 1s and 2s.
           And in this way we get our result.



Explanation : [0, 1, 2, 2, 1, 0 , 1]
			  count0 = 2 
			  count1 = 3
			  count2 = 2
			  Result :
			  [0, 0, 1, 1, 1, 2, 2]

CODE :

class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;

        int count0 = 0;
        int count1 = 0;
        int count2 = 0;
		
        for(int i = 0 ;i<n ; i++){
            if(nums[i] == 0)
                count0++;
            else if(nums[i] == 1)
                count1++;
            else
                count2++;
        }

        int index = 0;
        for(int i = 0 ; i<count0 ; i++){
            nums[index] = 0;
            index++;            
        }

        for(int i=0; i<count1 ; i++){
            nums[index] = 1;
            index++;
        }

        for(int i=0; i<count2; i++){
            nums[index] = 2;
            index++;
        }
    }
}

TC : O(N)
SC : O(1)

********************************************************************

//OPTIMAL Solution 
Approach : We know that we only have 0s, 1s and 2s in the array.
           We know that the 0s will come first in the sorted array, after that all the 1s will come and after that 2s.
		   So we can assign three variables/pointers i, j, k which will be the pointers for 0s, 1s and 2s.
		   Initially, i will be at the 0th index (Since we know that 0s will start from the first index itself)
		              j will be at the 0th index (Since we do not know the exact location where 1s will be in the array)
					  k will be at the n-1 index (Since we know for sure that 2 will be present at the last index in the sorted array)
		   Then we iterate over the array and check 
		   1. if arr[j] == 1
		   => then we dont do anything since this is what we want (j should be pointing to 1)
		   and we move j since we want to check for next element (j++)
		   
		   2. if arr[j] == 0
		   => then we know that 0 should be taken care by i so we swap arr[j] with arr[i]
		   and we move i and j both ahead (i++ and j++, since i and j started at the same index initially)
		   
		   3. if arr[j] == 2
		   => then we know that 2 should be taken care by k so we swap arr[j] with arr[k]
		   and we move k behind (k--, since k has 2 in place, now we go ahead to check with k--)
		   **We dont move j ahead here, reason being, imagine a situation where j and k were both pointing to a 2,
           now if after swapping arr[j] and arr[k], if we would have moved j ahead, 
		   previous j would be pointing to a 2 which is not according to what we had decided. A j should always point to 1.
		   Hence we only move k back in this case (k--)
			
		   We do this only until j <= k
		   Because once j crosses k, we would have our array sorted.
		   
Explanation : Dry run and try once.

CODE :
class Solution {
    public void sortColors(int[] nums) {
        
        int n = nums.length;

        int i = 0; 
        int j = 0;
        int k = n-1;

        while(j<=k){
            if(nums[j]==1)
                j++;
            else if(nums[j]==0){
                //swap(nums[j], nums[i]);
                nums[j] = nums[i];
                nums[i] = 0;
                i++;
                j++;
            }
            else{ //nums[j]==2
                //swap(nums[j], nums[k]);
                nums[j] = nums[k];
                nums[k] = 2;
                k--;
            }
        }
    }
}

TC : O(N)
SC : O(1)

********************************************************************
